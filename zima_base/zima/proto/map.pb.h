// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zima/proto/map.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fmap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fmap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zima_2fproto_2fmap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zima_2fproto_2fmap_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zima_2fproto_2fmap_2eproto;
namespace ZimaProto {
namespace Map {
class PCharGridMap2D;
struct PCharGridMap2DDefaultTypeInternal;
extern PCharGridMap2DDefaultTypeInternal _PCharGridMap2D_default_instance_;
class PDynamicMap2DInfo;
struct PDynamicMap2DInfoDefaultTypeInternal;
extern PDynamicMap2DInfoDefaultTypeInternal _PDynamicMap2DInfo_default_instance_;
class PMapCell;
struct PMapCellDefaultTypeInternal;
extern PMapCellDefaultTypeInternal _PMapCell_default_instance_;
class PMapCellBound;
struct PMapCellBoundDefaultTypeInternal;
extern PMapCellBoundDefaultTypeInternal _PMapCellBound_default_instance_;
class PMapPoint;
struct PMapPointDefaultTypeInternal;
extern PMapPointDefaultTypeInternal _PMapPoint_default_instance_;
class PMapPointBound;
struct PMapPointBoundDefaultTypeInternal;
extern PMapPointBoundDefaultTypeInternal _PMapPointBound_default_instance_;
class PMultiLayerCharGridMap2D;
struct PMultiLayerCharGridMap2DDefaultTypeInternal;
extern PMultiLayerCharGridMap2DDefaultTypeInternal _PMultiLayerCharGridMap2D_default_instance_;
class PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse;
struct PMultiLayerCharGridMap2D_MapDictEntry_DoNotUseDefaultTypeInternal;
extern PMultiLayerCharGridMap2D_MapDictEntry_DoNotUseDefaultTypeInternal _PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse_default_instance_;
class PSlamValueGridMap2D;
struct PSlamValueGridMap2DDefaultTypeInternal;
extern PSlamValueGridMap2DDefaultTypeInternal _PSlamValueGridMap2D_default_instance_;
}  // namespace Map
}  // namespace ZimaProto
PROTOBUF_NAMESPACE_OPEN
template<> ::ZimaProto::Map::PCharGridMap2D* Arena::CreateMaybeMessage<::ZimaProto::Map::PCharGridMap2D>(Arena*);
template<> ::ZimaProto::Map::PDynamicMap2DInfo* Arena::CreateMaybeMessage<::ZimaProto::Map::PDynamicMap2DInfo>(Arena*);
template<> ::ZimaProto::Map::PMapCell* Arena::CreateMaybeMessage<::ZimaProto::Map::PMapCell>(Arena*);
template<> ::ZimaProto::Map::PMapCellBound* Arena::CreateMaybeMessage<::ZimaProto::Map::PMapCellBound>(Arena*);
template<> ::ZimaProto::Map::PMapPoint* Arena::CreateMaybeMessage<::ZimaProto::Map::PMapPoint>(Arena*);
template<> ::ZimaProto::Map::PMapPointBound* Arena::CreateMaybeMessage<::ZimaProto::Map::PMapPointBound>(Arena*);
template<> ::ZimaProto::Map::PMultiLayerCharGridMap2D* Arena::CreateMaybeMessage<::ZimaProto::Map::PMultiLayerCharGridMap2D>(Arena*);
template<> ::ZimaProto::Map::PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse* Arena::CreateMaybeMessage<::ZimaProto::Map::PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse>(Arena*);
template<> ::ZimaProto::Map::PSlamValueGridMap2D* Arena::CreateMaybeMessage<::ZimaProto::Map::PSlamValueGridMap2D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ZimaProto {
namespace Map {

// ===================================================================

class PMapCell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PMapCell) */ {
 public:
  inline PMapCell() : PMapCell(nullptr) {}
  ~PMapCell() override;
  explicit PROTOBUF_CONSTEXPR PMapCell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMapCell(const PMapCell& from);
  PMapCell(PMapCell&& from) noexcept
    : PMapCell() {
    *this = ::std::move(from);
  }

  inline PMapCell& operator=(const PMapCell& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMapCell& operator=(PMapCell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMapCell& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMapCell* internal_default_instance() {
    return reinterpret_cast<const PMapCell*>(
               &_PMapCell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PMapCell& a, PMapCell& b) {
    a.Swap(&b);
  }
  inline void Swap(PMapCell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMapCell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMapCell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMapCell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMapCell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMapCell& from) {
    PMapCell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMapCell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PMapCell";
  }
  protected:
  explicit PMapCell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PMapCell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PMapCellBound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PMapCellBound) */ {
 public:
  inline PMapCellBound() : PMapCellBound(nullptr) {}
  ~PMapCellBound() override;
  explicit PROTOBUF_CONSTEXPR PMapCellBound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMapCellBound(const PMapCellBound& from);
  PMapCellBound(PMapCellBound&& from) noexcept
    : PMapCellBound() {
    *this = ::std::move(from);
  }

  inline PMapCellBound& operator=(const PMapCellBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMapCellBound& operator=(PMapCellBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMapCellBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMapCellBound* internal_default_instance() {
    return reinterpret_cast<const PMapCellBound*>(
               &_PMapCellBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PMapCellBound& a, PMapCellBound& b) {
    a.Swap(&b);
  }
  inline void Swap(PMapCellBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMapCellBound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMapCellBound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMapCellBound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMapCellBound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMapCellBound& from) {
    PMapCellBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMapCellBound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PMapCellBound";
  }
  protected:
  explicit PMapCellBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXMinFieldNumber = 1,
    kXMaxFieldNumber = 2,
    kYMinFieldNumber = 3,
    kYMaxFieldNumber = 4,
  };
  // int32 x_min = 1;
  void clear_x_min();
  int32_t x_min() const;
  void set_x_min(int32_t value);
  private:
  int32_t _internal_x_min() const;
  void _internal_set_x_min(int32_t value);
  public:

  // int32 x_max = 2;
  void clear_x_max();
  int32_t x_max() const;
  void set_x_max(int32_t value);
  private:
  int32_t _internal_x_max() const;
  void _internal_set_x_max(int32_t value);
  public:

  // int32 y_min = 3;
  void clear_y_min();
  int32_t y_min() const;
  void set_y_min(int32_t value);
  private:
  int32_t _internal_y_min() const;
  void _internal_set_y_min(int32_t value);
  public:

  // int32 y_max = 4;
  void clear_y_max();
  int32_t y_max() const;
  void set_y_max(int32_t value);
  private:
  int32_t _internal_y_max() const;
  void _internal_set_y_max(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PMapCellBound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_min_;
    int32_t x_max_;
    int32_t y_min_;
    int32_t y_max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PMapPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PMapPoint) */ {
 public:
  inline PMapPoint() : PMapPoint(nullptr) {}
  ~PMapPoint() override;
  explicit PROTOBUF_CONSTEXPR PMapPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMapPoint(const PMapPoint& from);
  PMapPoint(PMapPoint&& from) noexcept
    : PMapPoint() {
    *this = ::std::move(from);
  }

  inline PMapPoint& operator=(const PMapPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMapPoint& operator=(PMapPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMapPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMapPoint* internal_default_instance() {
    return reinterpret_cast<const PMapPoint*>(
               &_PMapPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PMapPoint& a, PMapPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PMapPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMapPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMapPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMapPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMapPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMapPoint& from) {
    PMapPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMapPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PMapPoint";
  }
  protected:
  explicit PMapPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDegreeFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float degree = 3;
  void clear_degree();
  float degree() const;
  void set_degree(float value);
  private:
  float _internal_degree() const;
  void _internal_set_degree(float value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PMapPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float degree_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PMapPointBound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PMapPointBound) */ {
 public:
  inline PMapPointBound() : PMapPointBound(nullptr) {}
  ~PMapPointBound() override;
  explicit PROTOBUF_CONSTEXPR PMapPointBound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMapPointBound(const PMapPointBound& from);
  PMapPointBound(PMapPointBound&& from) noexcept
    : PMapPointBound() {
    *this = ::std::move(from);
  }

  inline PMapPointBound& operator=(const PMapPointBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMapPointBound& operator=(PMapPointBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMapPointBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMapPointBound* internal_default_instance() {
    return reinterpret_cast<const PMapPointBound*>(
               &_PMapPointBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PMapPointBound& a, PMapPointBound& b) {
    a.Swap(&b);
  }
  inline void Swap(PMapPointBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMapPointBound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMapPointBound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMapPointBound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMapPointBound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMapPointBound& from) {
    PMapPointBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMapPointBound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PMapPointBound";
  }
  protected:
  explicit PMapPointBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXMinFieldNumber = 1,
    kXMaxFieldNumber = 2,
    kYMinFieldNumber = 3,
    kYMaxFieldNumber = 4,
  };
  // float x_min = 1;
  void clear_x_min();
  float x_min() const;
  void set_x_min(float value);
  private:
  float _internal_x_min() const;
  void _internal_set_x_min(float value);
  public:

  // float x_max = 2;
  void clear_x_max();
  float x_max() const;
  void set_x_max(float value);
  private:
  float _internal_x_max() const;
  void _internal_set_x_max(float value);
  public:

  // float y_min = 3;
  void clear_y_min();
  float y_min() const;
  void set_y_min(float value);
  private:
  float _internal_y_min() const;
  void _internal_set_y_min(float value);
  public:

  // float y_max = 4;
  void clear_y_max();
  float y_max() const;
  void set_y_max(float value);
  private:
  float _internal_y_max() const;
  void _internal_set_y_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PMapPointBound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_min_;
    float x_max_;
    float y_min_;
    float y_max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PDynamicMap2DInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PDynamicMap2DInfo) */ {
 public:
  inline PDynamicMap2DInfo() : PDynamicMap2DInfo(nullptr) {}
  ~PDynamicMap2DInfo() override;
  explicit PROTOBUF_CONSTEXPR PDynamicMap2DInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PDynamicMap2DInfo(const PDynamicMap2DInfo& from);
  PDynamicMap2DInfo(PDynamicMap2DInfo&& from) noexcept
    : PDynamicMap2DInfo() {
    *this = ::std::move(from);
  }

  inline PDynamicMap2DInfo& operator=(const PDynamicMap2DInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PDynamicMap2DInfo& operator=(PDynamicMap2DInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PDynamicMap2DInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PDynamicMap2DInfo* internal_default_instance() {
    return reinterpret_cast<const PDynamicMap2DInfo*>(
               &_PDynamicMap2DInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PDynamicMap2DInfo& a, PDynamicMap2DInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PDynamicMap2DInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PDynamicMap2DInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PDynamicMap2DInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PDynamicMap2DInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PDynamicMap2DInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PDynamicMap2DInfo& from) {
    PDynamicMap2DInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PDynamicMap2DInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PDynamicMap2DInfo";
  }
  protected:
  explicit PDynamicMap2DInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kXMinYMaxCellFieldNumber = 2,
    kResolutionFieldNumber = 3,
    kXRangeFieldNumber = 4,
    kYRangeFieldNumber = 5,
    kXReserveRangeFieldNumber = 6,
    kYReserveRangeFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ZimaProto.Map.PMapCell x_min_y_max_cell = 2;
  bool has_x_min_y_max_cell() const;
  private:
  bool _internal_has_x_min_y_max_cell() const;
  public:
  void clear_x_min_y_max_cell();
  const ::ZimaProto::Map::PMapCell& x_min_y_max_cell() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PMapCell* release_x_min_y_max_cell();
  ::ZimaProto::Map::PMapCell* mutable_x_min_y_max_cell();
  void set_allocated_x_min_y_max_cell(::ZimaProto::Map::PMapCell* x_min_y_max_cell);
  private:
  const ::ZimaProto::Map::PMapCell& _internal_x_min_y_max_cell() const;
  ::ZimaProto::Map::PMapCell* _internal_mutable_x_min_y_max_cell();
  public:
  void unsafe_arena_set_allocated_x_min_y_max_cell(
      ::ZimaProto::Map::PMapCell* x_min_y_max_cell);
  ::ZimaProto::Map::PMapCell* unsafe_arena_release_x_min_y_max_cell();

  // float resolution = 3;
  void clear_resolution();
  float resolution() const;
  void set_resolution(float value);
  private:
  float _internal_resolution() const;
  void _internal_set_resolution(float value);
  public:

  // int32 x_range = 4;
  void clear_x_range();
  int32_t x_range() const;
  void set_x_range(int32_t value);
  private:
  int32_t _internal_x_range() const;
  void _internal_set_x_range(int32_t value);
  public:

  // int32 y_range = 5;
  void clear_y_range();
  int32_t y_range() const;
  void set_y_range(int32_t value);
  private:
  int32_t _internal_y_range() const;
  void _internal_set_y_range(int32_t value);
  public:

  // int32 x_reserve_range = 6;
  void clear_x_reserve_range();
  int32_t x_reserve_range() const;
  void set_x_reserve_range(int32_t value);
  private:
  int32_t _internal_x_reserve_range() const;
  void _internal_set_x_reserve_range(int32_t value);
  public:

  // int32 y_reserve_range = 7;
  void clear_y_reserve_range();
  int32_t y_reserve_range() const;
  void set_y_reserve_range(int32_t value);
  private:
  int32_t _internal_y_reserve_range() const;
  void _internal_set_y_reserve_range(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PDynamicMap2DInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::ZimaProto::Map::PMapCell* x_min_y_max_cell_;
    float resolution_;
    int32_t x_range_;
    int32_t y_range_;
    int32_t x_reserve_range_;
    int32_t y_reserve_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PCharGridMap2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PCharGridMap2D) */ {
 public:
  inline PCharGridMap2D() : PCharGridMap2D(nullptr) {}
  ~PCharGridMap2D() override;
  explicit PROTOBUF_CONSTEXPR PCharGridMap2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCharGridMap2D(const PCharGridMap2D& from);
  PCharGridMap2D(PCharGridMap2D&& from) noexcept
    : PCharGridMap2D() {
    *this = ::std::move(from);
  }

  inline PCharGridMap2D& operator=(const PCharGridMap2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCharGridMap2D& operator=(PCharGridMap2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCharGridMap2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCharGridMap2D* internal_default_instance() {
    return reinterpret_cast<const PCharGridMap2D*>(
               &_PCharGridMap2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PCharGridMap2D& a, PCharGridMap2D& b) {
    a.Swap(&b);
  }
  inline void Swap(PCharGridMap2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCharGridMap2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCharGridMap2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCharGridMap2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCharGridMap2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PCharGridMap2D& from) {
    PCharGridMap2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCharGridMap2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PCharGridMap2D";
  }
  protected:
  explicit PCharGridMap2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kMapInfoFieldNumber = 1,
  };
  // string data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .ZimaProto.Map.PDynamicMap2DInfo map_info = 1;
  bool has_map_info() const;
  private:
  bool _internal_has_map_info() const;
  public:
  void clear_map_info();
  const ::ZimaProto::Map::PDynamicMap2DInfo& map_info() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PDynamicMap2DInfo* release_map_info();
  ::ZimaProto::Map::PDynamicMap2DInfo* mutable_map_info();
  void set_allocated_map_info(::ZimaProto::Map::PDynamicMap2DInfo* map_info);
  private:
  const ::ZimaProto::Map::PDynamicMap2DInfo& _internal_map_info() const;
  ::ZimaProto::Map::PDynamicMap2DInfo* _internal_mutable_map_info();
  public:
  void unsafe_arena_set_allocated_map_info(
      ::ZimaProto::Map::PDynamicMap2DInfo* map_info);
  ::ZimaProto::Map::PDynamicMap2DInfo* unsafe_arena_release_map_info();

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PCharGridMap2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::ZimaProto::Map::PDynamicMap2DInfo* map_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PSlamValueGridMap2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PSlamValueGridMap2D) */ {
 public:
  inline PSlamValueGridMap2D() : PSlamValueGridMap2D(nullptr) {}
  ~PSlamValueGridMap2D() override;
  explicit PROTOBUF_CONSTEXPR PSlamValueGridMap2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PSlamValueGridMap2D(const PSlamValueGridMap2D& from);
  PSlamValueGridMap2D(PSlamValueGridMap2D&& from) noexcept
    : PSlamValueGridMap2D() {
    *this = ::std::move(from);
  }

  inline PSlamValueGridMap2D& operator=(const PSlamValueGridMap2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline PSlamValueGridMap2D& operator=(PSlamValueGridMap2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PSlamValueGridMap2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const PSlamValueGridMap2D* internal_default_instance() {
    return reinterpret_cast<const PSlamValueGridMap2D*>(
               &_PSlamValueGridMap2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PSlamValueGridMap2D& a, PSlamValueGridMap2D& b) {
    a.Swap(&b);
  }
  inline void Swap(PSlamValueGridMap2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PSlamValueGridMap2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PSlamValueGridMap2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PSlamValueGridMap2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PSlamValueGridMap2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PSlamValueGridMap2D& from) {
    PSlamValueGridMap2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PSlamValueGridMap2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PSlamValueGridMap2D";
  }
  protected:
  explicit PSlamValueGridMap2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kMapInfoFieldNumber = 1,
  };
  // repeated int32 data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  int32_t _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data() const;
  void _internal_add_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data();
  public:
  int32_t data(int index) const;
  void set_data(int index, int32_t value);
  void add_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data();

  // .ZimaProto.Map.PDynamicMap2DInfo map_info = 1;
  bool has_map_info() const;
  private:
  bool _internal_has_map_info() const;
  public:
  void clear_map_info();
  const ::ZimaProto::Map::PDynamicMap2DInfo& map_info() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PDynamicMap2DInfo* release_map_info();
  ::ZimaProto::Map::PDynamicMap2DInfo* mutable_map_info();
  void set_allocated_map_info(::ZimaProto::Map::PDynamicMap2DInfo* map_info);
  private:
  const ::ZimaProto::Map::PDynamicMap2DInfo& _internal_map_info() const;
  ::ZimaProto::Map::PDynamicMap2DInfo* _internal_mutable_map_info();
  public:
  void unsafe_arena_set_allocated_map_info(
      ::ZimaProto::Map::PDynamicMap2DInfo* map_info);
  ::ZimaProto::Map::PDynamicMap2DInfo* unsafe_arena_release_map_info();

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PSlamValueGridMap2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_;
    mutable std::atomic<int> _data_cached_byte_size_;
    ::ZimaProto::Map::PDynamicMap2DInfo* map_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// -------------------------------------------------------------------

class PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse, 
    std::string, ::ZimaProto::Map::PCharGridMap2D,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse, 
    std::string, ::ZimaProto::Map::PCharGridMap2D,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse& other);
  static const PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse*>(&_PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ZimaProto.Map.PMultiLayerCharGridMap2D.MapDictEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};

// -------------------------------------------------------------------

class PMultiLayerCharGridMap2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.Map.PMultiLayerCharGridMap2D) */ {
 public:
  inline PMultiLayerCharGridMap2D() : PMultiLayerCharGridMap2D(nullptr) {}
  ~PMultiLayerCharGridMap2D() override;
  explicit PROTOBUF_CONSTEXPR PMultiLayerCharGridMap2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMultiLayerCharGridMap2D(const PMultiLayerCharGridMap2D& from);
  PMultiLayerCharGridMap2D(PMultiLayerCharGridMap2D&& from) noexcept
    : PMultiLayerCharGridMap2D() {
    *this = ::std::move(from);
  }

  inline PMultiLayerCharGridMap2D& operator=(const PMultiLayerCharGridMap2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMultiLayerCharGridMap2D& operator=(PMultiLayerCharGridMap2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMultiLayerCharGridMap2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMultiLayerCharGridMap2D* internal_default_instance() {
    return reinterpret_cast<const PMultiLayerCharGridMap2D*>(
               &_PMultiLayerCharGridMap2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PMultiLayerCharGridMap2D& a, PMultiLayerCharGridMap2D& b) {
    a.Swap(&b);
  }
  inline void Swap(PMultiLayerCharGridMap2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMultiLayerCharGridMap2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMultiLayerCharGridMap2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMultiLayerCharGridMap2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMultiLayerCharGridMap2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMultiLayerCharGridMap2D& from) {
    PMultiLayerCharGridMap2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMultiLayerCharGridMap2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.Map.PMultiLayerCharGridMap2D";
  }
  protected:
  explicit PMultiLayerCharGridMap2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMapDictFieldNumber = 1,
  };
  // map<string, .ZimaProto.Map.PCharGridMap2D> map_dict = 1;
  int map_dict_size() const;
  private:
  int _internal_map_dict_size() const;
  public:
  void clear_map_dict();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >&
      _internal_map_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >*
      _internal_mutable_map_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >&
      map_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >*
      mutable_map_dict();

  // @@protoc_insertion_point(class_scope:ZimaProto.Map.PMultiLayerCharGridMap2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PMultiLayerCharGridMap2D_MapDictEntry_DoNotUse,
        std::string, ::ZimaProto::Map::PCharGridMap2D,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> map_dict_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fmap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PMapCell

// int32 x = 1;
inline void PMapCell::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t PMapCell::_internal_x() const {
  return _impl_.x_;
}
inline int32_t PMapCell::x() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCell.x)
  return _internal_x();
}
inline void PMapCell::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void PMapCell::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCell.x)
}

// int32 y = 2;
inline void PMapCell::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t PMapCell::_internal_y() const {
  return _impl_.y_;
}
inline int32_t PMapCell::y() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCell.y)
  return _internal_y();
}
inline void PMapCell::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void PMapCell::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCell.y)
}

// -------------------------------------------------------------------

// PMapCellBound

// int32 x_min = 1;
inline void PMapCellBound::clear_x_min() {
  _impl_.x_min_ = 0;
}
inline int32_t PMapCellBound::_internal_x_min() const {
  return _impl_.x_min_;
}
inline int32_t PMapCellBound::x_min() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCellBound.x_min)
  return _internal_x_min();
}
inline void PMapCellBound::_internal_set_x_min(int32_t value) {
  
  _impl_.x_min_ = value;
}
inline void PMapCellBound::set_x_min(int32_t value) {
  _internal_set_x_min(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCellBound.x_min)
}

// int32 x_max = 2;
inline void PMapCellBound::clear_x_max() {
  _impl_.x_max_ = 0;
}
inline int32_t PMapCellBound::_internal_x_max() const {
  return _impl_.x_max_;
}
inline int32_t PMapCellBound::x_max() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCellBound.x_max)
  return _internal_x_max();
}
inline void PMapCellBound::_internal_set_x_max(int32_t value) {
  
  _impl_.x_max_ = value;
}
inline void PMapCellBound::set_x_max(int32_t value) {
  _internal_set_x_max(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCellBound.x_max)
}

// int32 y_min = 3;
inline void PMapCellBound::clear_y_min() {
  _impl_.y_min_ = 0;
}
inline int32_t PMapCellBound::_internal_y_min() const {
  return _impl_.y_min_;
}
inline int32_t PMapCellBound::y_min() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCellBound.y_min)
  return _internal_y_min();
}
inline void PMapCellBound::_internal_set_y_min(int32_t value) {
  
  _impl_.y_min_ = value;
}
inline void PMapCellBound::set_y_min(int32_t value) {
  _internal_set_y_min(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCellBound.y_min)
}

// int32 y_max = 4;
inline void PMapCellBound::clear_y_max() {
  _impl_.y_max_ = 0;
}
inline int32_t PMapCellBound::_internal_y_max() const {
  return _impl_.y_max_;
}
inline int32_t PMapCellBound::y_max() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapCellBound.y_max)
  return _internal_y_max();
}
inline void PMapCellBound::_internal_set_y_max(int32_t value) {
  
  _impl_.y_max_ = value;
}
inline void PMapCellBound::set_y_max(int32_t value) {
  _internal_set_y_max(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapCellBound.y_max)
}

// -------------------------------------------------------------------

// PMapPoint

// float x = 1;
inline void PMapPoint::clear_x() {
  _impl_.x_ = 0;
}
inline float PMapPoint::_internal_x() const {
  return _impl_.x_;
}
inline float PMapPoint::x() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPoint.x)
  return _internal_x();
}
inline void PMapPoint::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void PMapPoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPoint.x)
}

// float y = 2;
inline void PMapPoint::clear_y() {
  _impl_.y_ = 0;
}
inline float PMapPoint::_internal_y() const {
  return _impl_.y_;
}
inline float PMapPoint::y() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPoint.y)
  return _internal_y();
}
inline void PMapPoint::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void PMapPoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPoint.y)
}

// float degree = 3;
inline void PMapPoint::clear_degree() {
  _impl_.degree_ = 0;
}
inline float PMapPoint::_internal_degree() const {
  return _impl_.degree_;
}
inline float PMapPoint::degree() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPoint.degree)
  return _internal_degree();
}
inline void PMapPoint::_internal_set_degree(float value) {
  
  _impl_.degree_ = value;
}
inline void PMapPoint::set_degree(float value) {
  _internal_set_degree(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPoint.degree)
}

// -------------------------------------------------------------------

// PMapPointBound

// float x_min = 1;
inline void PMapPointBound::clear_x_min() {
  _impl_.x_min_ = 0;
}
inline float PMapPointBound::_internal_x_min() const {
  return _impl_.x_min_;
}
inline float PMapPointBound::x_min() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPointBound.x_min)
  return _internal_x_min();
}
inline void PMapPointBound::_internal_set_x_min(float value) {
  
  _impl_.x_min_ = value;
}
inline void PMapPointBound::set_x_min(float value) {
  _internal_set_x_min(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPointBound.x_min)
}

// float x_max = 2;
inline void PMapPointBound::clear_x_max() {
  _impl_.x_max_ = 0;
}
inline float PMapPointBound::_internal_x_max() const {
  return _impl_.x_max_;
}
inline float PMapPointBound::x_max() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPointBound.x_max)
  return _internal_x_max();
}
inline void PMapPointBound::_internal_set_x_max(float value) {
  
  _impl_.x_max_ = value;
}
inline void PMapPointBound::set_x_max(float value) {
  _internal_set_x_max(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPointBound.x_max)
}

// float y_min = 3;
inline void PMapPointBound::clear_y_min() {
  _impl_.y_min_ = 0;
}
inline float PMapPointBound::_internal_y_min() const {
  return _impl_.y_min_;
}
inline float PMapPointBound::y_min() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPointBound.y_min)
  return _internal_y_min();
}
inline void PMapPointBound::_internal_set_y_min(float value) {
  
  _impl_.y_min_ = value;
}
inline void PMapPointBound::set_y_min(float value) {
  _internal_set_y_min(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPointBound.y_min)
}

// float y_max = 4;
inline void PMapPointBound::clear_y_max() {
  _impl_.y_max_ = 0;
}
inline float PMapPointBound::_internal_y_max() const {
  return _impl_.y_max_;
}
inline float PMapPointBound::y_max() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PMapPointBound.y_max)
  return _internal_y_max();
}
inline void PMapPointBound::_internal_set_y_max(float value) {
  
  _impl_.y_max_ = value;
}
inline void PMapPointBound::set_y_max(float value) {
  _internal_set_y_max(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PMapPointBound.y_max)
}

// -------------------------------------------------------------------

// PDynamicMap2DInfo

// string name = 1;
inline void PDynamicMap2DInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PDynamicMap2DInfo::name() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PDynamicMap2DInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.name)
}
inline std::string* PDynamicMap2DInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ZimaProto.Map.PDynamicMap2DInfo.name)
  return _s;
}
inline const std::string& PDynamicMap2DInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PDynamicMap2DInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PDynamicMap2DInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PDynamicMap2DInfo::release_name() {
  // @@protoc_insertion_point(field_release:ZimaProto.Map.PDynamicMap2DInfo.name)
  return _impl_.name_.Release();
}
inline void PDynamicMap2DInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.Map.PDynamicMap2DInfo.name)
}

// .ZimaProto.Map.PMapCell x_min_y_max_cell = 2;
inline bool PDynamicMap2DInfo::_internal_has_x_min_y_max_cell() const {
  return this != internal_default_instance() && _impl_.x_min_y_max_cell_ != nullptr;
}
inline bool PDynamicMap2DInfo::has_x_min_y_max_cell() const {
  return _internal_has_x_min_y_max_cell();
}
inline void PDynamicMap2DInfo::clear_x_min_y_max_cell() {
  if (GetArenaForAllocation() == nullptr && _impl_.x_min_y_max_cell_ != nullptr) {
    delete _impl_.x_min_y_max_cell_;
  }
  _impl_.x_min_y_max_cell_ = nullptr;
}
inline const ::ZimaProto::Map::PMapCell& PDynamicMap2DInfo::_internal_x_min_y_max_cell() const {
  const ::ZimaProto::Map::PMapCell* p = _impl_.x_min_y_max_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PMapCell&>(
      ::ZimaProto::Map::_PMapCell_default_instance_);
}
inline const ::ZimaProto::Map::PMapCell& PDynamicMap2DInfo::x_min_y_max_cell() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.x_min_y_max_cell)
  return _internal_x_min_y_max_cell();
}
inline void PDynamicMap2DInfo::unsafe_arena_set_allocated_x_min_y_max_cell(
    ::ZimaProto::Map::PMapCell* x_min_y_max_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_min_y_max_cell_);
  }
  _impl_.x_min_y_max_cell_ = x_min_y_max_cell;
  if (x_min_y_max_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.Map.PDynamicMap2DInfo.x_min_y_max_cell)
}
inline ::ZimaProto::Map::PMapCell* PDynamicMap2DInfo::release_x_min_y_max_cell() {
  
  ::ZimaProto::Map::PMapCell* temp = _impl_.x_min_y_max_cell_;
  _impl_.x_min_y_max_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PMapCell* PDynamicMap2DInfo::unsafe_arena_release_x_min_y_max_cell() {
  // @@protoc_insertion_point(field_release:ZimaProto.Map.PDynamicMap2DInfo.x_min_y_max_cell)
  
  ::ZimaProto::Map::PMapCell* temp = _impl_.x_min_y_max_cell_;
  _impl_.x_min_y_max_cell_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PMapCell* PDynamicMap2DInfo::_internal_mutable_x_min_y_max_cell() {
  
  if (_impl_.x_min_y_max_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PMapCell>(GetArenaForAllocation());
    _impl_.x_min_y_max_cell_ = p;
  }
  return _impl_.x_min_y_max_cell_;
}
inline ::ZimaProto::Map::PMapCell* PDynamicMap2DInfo::mutable_x_min_y_max_cell() {
  ::ZimaProto::Map::PMapCell* _msg = _internal_mutable_x_min_y_max_cell();
  // @@protoc_insertion_point(field_mutable:ZimaProto.Map.PDynamicMap2DInfo.x_min_y_max_cell)
  return _msg;
}
inline void PDynamicMap2DInfo::set_allocated_x_min_y_max_cell(::ZimaProto::Map::PMapCell* x_min_y_max_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.x_min_y_max_cell_;
  }
  if (x_min_y_max_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(x_min_y_max_cell);
    if (message_arena != submessage_arena) {
      x_min_y_max_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x_min_y_max_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.x_min_y_max_cell_ = x_min_y_max_cell;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.Map.PDynamicMap2DInfo.x_min_y_max_cell)
}

// float resolution = 3;
inline void PDynamicMap2DInfo::clear_resolution() {
  _impl_.resolution_ = 0;
}
inline float PDynamicMap2DInfo::_internal_resolution() const {
  return _impl_.resolution_;
}
inline float PDynamicMap2DInfo::resolution() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.resolution)
  return _internal_resolution();
}
inline void PDynamicMap2DInfo::_internal_set_resolution(float value) {
  
  _impl_.resolution_ = value;
}
inline void PDynamicMap2DInfo::set_resolution(float value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.resolution)
}

// int32 x_range = 4;
inline void PDynamicMap2DInfo::clear_x_range() {
  _impl_.x_range_ = 0;
}
inline int32_t PDynamicMap2DInfo::_internal_x_range() const {
  return _impl_.x_range_;
}
inline int32_t PDynamicMap2DInfo::x_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.x_range)
  return _internal_x_range();
}
inline void PDynamicMap2DInfo::_internal_set_x_range(int32_t value) {
  
  _impl_.x_range_ = value;
}
inline void PDynamicMap2DInfo::set_x_range(int32_t value) {
  _internal_set_x_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.x_range)
}

// int32 y_range = 5;
inline void PDynamicMap2DInfo::clear_y_range() {
  _impl_.y_range_ = 0;
}
inline int32_t PDynamicMap2DInfo::_internal_y_range() const {
  return _impl_.y_range_;
}
inline int32_t PDynamicMap2DInfo::y_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.y_range)
  return _internal_y_range();
}
inline void PDynamicMap2DInfo::_internal_set_y_range(int32_t value) {
  
  _impl_.y_range_ = value;
}
inline void PDynamicMap2DInfo::set_y_range(int32_t value) {
  _internal_set_y_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.y_range)
}

// int32 x_reserve_range = 6;
inline void PDynamicMap2DInfo::clear_x_reserve_range() {
  _impl_.x_reserve_range_ = 0;
}
inline int32_t PDynamicMap2DInfo::_internal_x_reserve_range() const {
  return _impl_.x_reserve_range_;
}
inline int32_t PDynamicMap2DInfo::x_reserve_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.x_reserve_range)
  return _internal_x_reserve_range();
}
inline void PDynamicMap2DInfo::_internal_set_x_reserve_range(int32_t value) {
  
  _impl_.x_reserve_range_ = value;
}
inline void PDynamicMap2DInfo::set_x_reserve_range(int32_t value) {
  _internal_set_x_reserve_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.x_reserve_range)
}

// int32 y_reserve_range = 7;
inline void PDynamicMap2DInfo::clear_y_reserve_range() {
  _impl_.y_reserve_range_ = 0;
}
inline int32_t PDynamicMap2DInfo::_internal_y_reserve_range() const {
  return _impl_.y_reserve_range_;
}
inline int32_t PDynamicMap2DInfo::y_reserve_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PDynamicMap2DInfo.y_reserve_range)
  return _internal_y_reserve_range();
}
inline void PDynamicMap2DInfo::_internal_set_y_reserve_range(int32_t value) {
  
  _impl_.y_reserve_range_ = value;
}
inline void PDynamicMap2DInfo::set_y_reserve_range(int32_t value) {
  _internal_set_y_reserve_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PDynamicMap2DInfo.y_reserve_range)
}

// -------------------------------------------------------------------

// PCharGridMap2D

// .ZimaProto.Map.PDynamicMap2DInfo map_info = 1;
inline bool PCharGridMap2D::_internal_has_map_info() const {
  return this != internal_default_instance() && _impl_.map_info_ != nullptr;
}
inline bool PCharGridMap2D::has_map_info() const {
  return _internal_has_map_info();
}
inline void PCharGridMap2D::clear_map_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.map_info_ != nullptr) {
    delete _impl_.map_info_;
  }
  _impl_.map_info_ = nullptr;
}
inline const ::ZimaProto::Map::PDynamicMap2DInfo& PCharGridMap2D::_internal_map_info() const {
  const ::ZimaProto::Map::PDynamicMap2DInfo* p = _impl_.map_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PDynamicMap2DInfo&>(
      ::ZimaProto::Map::_PDynamicMap2DInfo_default_instance_);
}
inline const ::ZimaProto::Map::PDynamicMap2DInfo& PCharGridMap2D::map_info() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PCharGridMap2D.map_info)
  return _internal_map_info();
}
inline void PCharGridMap2D::unsafe_arena_set_allocated_map_info(
    ::ZimaProto::Map::PDynamicMap2DInfo* map_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_info_);
  }
  _impl_.map_info_ = map_info;
  if (map_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.Map.PCharGridMap2D.map_info)
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PCharGridMap2D::release_map_info() {
  
  ::ZimaProto::Map::PDynamicMap2DInfo* temp = _impl_.map_info_;
  _impl_.map_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PCharGridMap2D::unsafe_arena_release_map_info() {
  // @@protoc_insertion_point(field_release:ZimaProto.Map.PCharGridMap2D.map_info)
  
  ::ZimaProto::Map::PDynamicMap2DInfo* temp = _impl_.map_info_;
  _impl_.map_info_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PCharGridMap2D::_internal_mutable_map_info() {
  
  if (_impl_.map_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PDynamicMap2DInfo>(GetArenaForAllocation());
    _impl_.map_info_ = p;
  }
  return _impl_.map_info_;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PCharGridMap2D::mutable_map_info() {
  ::ZimaProto::Map::PDynamicMap2DInfo* _msg = _internal_mutable_map_info();
  // @@protoc_insertion_point(field_mutable:ZimaProto.Map.PCharGridMap2D.map_info)
  return _msg;
}
inline void PCharGridMap2D::set_allocated_map_info(::ZimaProto::Map::PDynamicMap2DInfo* map_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_info_;
  }
  if (map_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_info);
    if (message_arena != submessage_arena) {
      map_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_info_ = map_info;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.Map.PCharGridMap2D.map_info)
}

// string data = 2;
inline void PCharGridMap2D::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PCharGridMap2D::data() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PCharGridMap2D.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PCharGridMap2D::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PCharGridMap2D.data)
}
inline std::string* PCharGridMap2D::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ZimaProto.Map.PCharGridMap2D.data)
  return _s;
}
inline const std::string& PCharGridMap2D::_internal_data() const {
  return _impl_.data_.Get();
}
inline void PCharGridMap2D::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* PCharGridMap2D::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* PCharGridMap2D::release_data() {
  // @@protoc_insertion_point(field_release:ZimaProto.Map.PCharGridMap2D.data)
  return _impl_.data_.Release();
}
inline void PCharGridMap2D::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.Map.PCharGridMap2D.data)
}

// -------------------------------------------------------------------

// PSlamValueGridMap2D

// .ZimaProto.Map.PDynamicMap2DInfo map_info = 1;
inline bool PSlamValueGridMap2D::_internal_has_map_info() const {
  return this != internal_default_instance() && _impl_.map_info_ != nullptr;
}
inline bool PSlamValueGridMap2D::has_map_info() const {
  return _internal_has_map_info();
}
inline void PSlamValueGridMap2D::clear_map_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.map_info_ != nullptr) {
    delete _impl_.map_info_;
  }
  _impl_.map_info_ = nullptr;
}
inline const ::ZimaProto::Map::PDynamicMap2DInfo& PSlamValueGridMap2D::_internal_map_info() const {
  const ::ZimaProto::Map::PDynamicMap2DInfo* p = _impl_.map_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PDynamicMap2DInfo&>(
      ::ZimaProto::Map::_PDynamicMap2DInfo_default_instance_);
}
inline const ::ZimaProto::Map::PDynamicMap2DInfo& PSlamValueGridMap2D::map_info() const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PSlamValueGridMap2D.map_info)
  return _internal_map_info();
}
inline void PSlamValueGridMap2D::unsafe_arena_set_allocated_map_info(
    ::ZimaProto::Map::PDynamicMap2DInfo* map_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_info_);
  }
  _impl_.map_info_ = map_info;
  if (map_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.Map.PSlamValueGridMap2D.map_info)
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PSlamValueGridMap2D::release_map_info() {
  
  ::ZimaProto::Map::PDynamicMap2DInfo* temp = _impl_.map_info_;
  _impl_.map_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PSlamValueGridMap2D::unsafe_arena_release_map_info() {
  // @@protoc_insertion_point(field_release:ZimaProto.Map.PSlamValueGridMap2D.map_info)
  
  ::ZimaProto::Map::PDynamicMap2DInfo* temp = _impl_.map_info_;
  _impl_.map_info_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PSlamValueGridMap2D::_internal_mutable_map_info() {
  
  if (_impl_.map_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PDynamicMap2DInfo>(GetArenaForAllocation());
    _impl_.map_info_ = p;
  }
  return _impl_.map_info_;
}
inline ::ZimaProto::Map::PDynamicMap2DInfo* PSlamValueGridMap2D::mutable_map_info() {
  ::ZimaProto::Map::PDynamicMap2DInfo* _msg = _internal_mutable_map_info();
  // @@protoc_insertion_point(field_mutable:ZimaProto.Map.PSlamValueGridMap2D.map_info)
  return _msg;
}
inline void PSlamValueGridMap2D::set_allocated_map_info(::ZimaProto::Map::PDynamicMap2DInfo* map_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_info_;
  }
  if (map_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_info);
    if (message_arena != submessage_arena) {
      map_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_info_ = map_info;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.Map.PSlamValueGridMap2D.map_info)
}

// repeated int32 data = 2;
inline int PSlamValueGridMap2D::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int PSlamValueGridMap2D::data_size() const {
  return _internal_data_size();
}
inline void PSlamValueGridMap2D::clear_data() {
  _impl_.data_.Clear();
}
inline int32_t PSlamValueGridMap2D::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline int32_t PSlamValueGridMap2D::data(int index) const {
  // @@protoc_insertion_point(field_get:ZimaProto.Map.PSlamValueGridMap2D.data)
  return _internal_data(index);
}
inline void PSlamValueGridMap2D::set_data(int index, int32_t value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:ZimaProto.Map.PSlamValueGridMap2D.data)
}
inline void PSlamValueGridMap2D::_internal_add_data(int32_t value) {
  _impl_.data_.Add(value);
}
inline void PSlamValueGridMap2D::add_data(int32_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:ZimaProto.Map.PSlamValueGridMap2D.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PSlamValueGridMap2D::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PSlamValueGridMap2D::data() const {
  // @@protoc_insertion_point(field_list:ZimaProto.Map.PSlamValueGridMap2D.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PSlamValueGridMap2D::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PSlamValueGridMap2D::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ZimaProto.Map.PSlamValueGridMap2D.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PMultiLayerCharGridMap2D

// map<string, .ZimaProto.Map.PCharGridMap2D> map_dict = 1;
inline int PMultiLayerCharGridMap2D::_internal_map_dict_size() const {
  return _impl_.map_dict_.size();
}
inline int PMultiLayerCharGridMap2D::map_dict_size() const {
  return _internal_map_dict_size();
}
inline void PMultiLayerCharGridMap2D::clear_map_dict() {
  _impl_.map_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >&
PMultiLayerCharGridMap2D::_internal_map_dict() const {
  return _impl_.map_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >&
PMultiLayerCharGridMap2D::map_dict() const {
  // @@protoc_insertion_point(field_map:ZimaProto.Map.PMultiLayerCharGridMap2D.map_dict)
  return _internal_map_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >*
PMultiLayerCharGridMap2D::_internal_mutable_map_dict() {
  return _impl_.map_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::Map::PCharGridMap2D >*
PMultiLayerCharGridMap2D::mutable_map_dict() {
  // @@protoc_insertion_point(field_mutable_map:ZimaProto.Map.PMultiLayerCharGridMap2D.map_dict)
  return _internal_mutable_map_dict();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Map
}  // namespace ZimaProto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fmap_2eproto

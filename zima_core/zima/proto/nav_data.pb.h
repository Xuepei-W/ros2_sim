// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zima/proto/nav_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fnav_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fnav_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "zima/proto/map.pb.h"
#include "zima/proto/probability_map.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zima_2fproto_2fnav_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zima_2fproto_2fnav_5fdata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zima_2fproto_2fnav_5fdata_2eproto;
namespace ZimaProto {
namespace NavData {
class PBlockArea;
struct PBlockAreaDefaultTypeInternal;
extern PBlockAreaDefaultTypeInternal _PBlockArea_default_instance_;
class PNavData;
struct PNavDataDefaultTypeInternal;
extern PNavDataDefaultTypeInternal _PNavData_default_instance_;
class PNavData_BlockAreasEntry_DoNotUse;
struct PNavData_BlockAreasEntry_DoNotUseDefaultTypeInternal;
extern PNavData_BlockAreasEntry_DoNotUseDefaultTypeInternal _PNavData_BlockAreasEntry_DoNotUse_default_instance_;
class PNavData_RoomsInfoEntry_DoNotUse;
struct PNavData_RoomsInfoEntry_DoNotUseDefaultTypeInternal;
extern PNavData_RoomsInfoEntry_DoNotUseDefaultTypeInternal _PNavData_RoomsInfoEntry_DoNotUse_default_instance_;
class PNavData_VirtualWallsEntry_DoNotUse;
struct PNavData_VirtualWallsEntry_DoNotUseDefaultTypeInternal;
extern PNavData_VirtualWallsEntry_DoNotUseDefaultTypeInternal _PNavData_VirtualWallsEntry_DoNotUse_default_instance_;
class PRoomInfo;
struct PRoomInfoDefaultTypeInternal;
extern PRoomInfoDefaultTypeInternal _PRoomInfo_default_instance_;
class PVirtualWall;
struct PVirtualWallDefaultTypeInternal;
extern PVirtualWallDefaultTypeInternal _PVirtualWall_default_instance_;
}  // namespace NavData
}  // namespace ZimaProto
PROTOBUF_NAMESPACE_OPEN
template<> ::ZimaProto::NavData::PBlockArea* Arena::CreateMaybeMessage<::ZimaProto::NavData::PBlockArea>(Arena*);
template<> ::ZimaProto::NavData::PNavData* Arena::CreateMaybeMessage<::ZimaProto::NavData::PNavData>(Arena*);
template<> ::ZimaProto::NavData::PNavData_BlockAreasEntry_DoNotUse* Arena::CreateMaybeMessage<::ZimaProto::NavData::PNavData_BlockAreasEntry_DoNotUse>(Arena*);
template<> ::ZimaProto::NavData::PNavData_RoomsInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::ZimaProto::NavData::PNavData_RoomsInfoEntry_DoNotUse>(Arena*);
template<> ::ZimaProto::NavData::PNavData_VirtualWallsEntry_DoNotUse* Arena::CreateMaybeMessage<::ZimaProto::NavData::PNavData_VirtualWallsEntry_DoNotUse>(Arena*);
template<> ::ZimaProto::NavData::PRoomInfo* Arena::CreateMaybeMessage<::ZimaProto::NavData::PRoomInfo>(Arena*);
template<> ::ZimaProto::NavData::PVirtualWall* Arena::CreateMaybeMessage<::ZimaProto::NavData::PVirtualWall>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ZimaProto {
namespace NavData {

enum PUserBlockType : int {
  kStrictBlock = 0,
  kAvoidWaterBlock = 1,
  kCarpetBlock = 2,
  PUserBlockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PUserBlockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PUserBlockType_IsValid(int value);
constexpr PUserBlockType PUserBlockType_MIN = kStrictBlock;
constexpr PUserBlockType PUserBlockType_MAX = kCarpetBlock;
constexpr int PUserBlockType_ARRAYSIZE = PUserBlockType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PUserBlockType_descriptor();
template<typename T>
inline const std::string& PUserBlockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PUserBlockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PUserBlockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PUserBlockType_descriptor(), enum_t_value);
}
inline bool PUserBlockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PUserBlockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PUserBlockType>(
    PUserBlockType_descriptor(), name, value);
}
// ===================================================================

class PRoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.NavData.PRoomInfo) */ {
 public:
  inline PRoomInfo() : PRoomInfo(nullptr) {}
  ~PRoomInfo() override;
  explicit PROTOBUF_CONSTEXPR PRoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PRoomInfo(const PRoomInfo& from);
  PRoomInfo(PRoomInfo&& from) noexcept
    : PRoomInfo() {
    *this = ::std::move(from);
  }

  inline PRoomInfo& operator=(const PRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PRoomInfo& operator=(PRoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PRoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PRoomInfo* internal_default_instance() {
    return reinterpret_cast<const PRoomInfo*>(
               &_PRoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PRoomInfo& a, PRoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PRoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PRoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PRoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PRoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PRoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PRoomInfo& from) {
    PRoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PRoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.NavData.PRoomInfo";
  }
  protected:
  explicit PRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIndexFieldNumber = 1,
    kRoomBoundFieldNumber = 2,
    kSectionBaseCellFieldNumber = 3,
    kSectionXRangeFieldNumber = 4,
    kSectionYRangeFieldNumber = 5,
  };
  // string room_index = 1;
  void clear_room_index();
  const std::string& room_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_index();
  PROTOBUF_NODISCARD std::string* release_room_index();
  void set_allocated_room_index(std::string* room_index);
  private:
  const std::string& _internal_room_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_index(const std::string& value);
  std::string* _internal_mutable_room_index();
  public:

  // .ZimaProto.Map.PMapCellBound room_bound = 2;
  bool has_room_bound() const;
  private:
  bool _internal_has_room_bound() const;
  public:
  void clear_room_bound();
  const ::ZimaProto::Map::PMapCellBound& room_bound() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PMapCellBound* release_room_bound();
  ::ZimaProto::Map::PMapCellBound* mutable_room_bound();
  void set_allocated_room_bound(::ZimaProto::Map::PMapCellBound* room_bound);
  private:
  const ::ZimaProto::Map::PMapCellBound& _internal_room_bound() const;
  ::ZimaProto::Map::PMapCellBound* _internal_mutable_room_bound();
  public:
  void unsafe_arena_set_allocated_room_bound(
      ::ZimaProto::Map::PMapCellBound* room_bound);
  ::ZimaProto::Map::PMapCellBound* unsafe_arena_release_room_bound();

  // .ZimaProto.Map.PMapCell section_base_cell = 3;
  bool has_section_base_cell() const;
  private:
  bool _internal_has_section_base_cell() const;
  public:
  void clear_section_base_cell();
  const ::ZimaProto::Map::PMapCell& section_base_cell() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PMapCell* release_section_base_cell();
  ::ZimaProto::Map::PMapCell* mutable_section_base_cell();
  void set_allocated_section_base_cell(::ZimaProto::Map::PMapCell* section_base_cell);
  private:
  const ::ZimaProto::Map::PMapCell& _internal_section_base_cell() const;
  ::ZimaProto::Map::PMapCell* _internal_mutable_section_base_cell();
  public:
  void unsafe_arena_set_allocated_section_base_cell(
      ::ZimaProto::Map::PMapCell* section_base_cell);
  ::ZimaProto::Map::PMapCell* unsafe_arena_release_section_base_cell();

  // uint32 section_x_range = 4;
  void clear_section_x_range();
  uint32_t section_x_range() const;
  void set_section_x_range(uint32_t value);
  private:
  uint32_t _internal_section_x_range() const;
  void _internal_set_section_x_range(uint32_t value);
  public:

  // uint32 section_y_range = 5;
  void clear_section_y_range();
  uint32_t section_y_range() const;
  void set_section_y_range(uint32_t value);
  private:
  uint32_t _internal_section_y_range() const;
  void _internal_set_section_y_range(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.NavData.PRoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_index_;
    ::ZimaProto::Map::PMapCellBound* room_bound_;
    ::ZimaProto::Map::PMapCell* section_base_cell_;
    uint32_t section_x_range_;
    uint32_t section_y_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PVirtualWall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.NavData.PVirtualWall) */ {
 public:
  inline PVirtualWall() : PVirtualWall(nullptr) {}
  ~PVirtualWall() override;
  explicit PROTOBUF_CONSTEXPR PVirtualWall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PVirtualWall(const PVirtualWall& from);
  PVirtualWall(PVirtualWall&& from) noexcept
    : PVirtualWall() {
    *this = ::std::move(from);
  }

  inline PVirtualWall& operator=(const PVirtualWall& from) {
    CopyFrom(from);
    return *this;
  }
  inline PVirtualWall& operator=(PVirtualWall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PVirtualWall& default_instance() {
    return *internal_default_instance();
  }
  static inline const PVirtualWall* internal_default_instance() {
    return reinterpret_cast<const PVirtualWall*>(
               &_PVirtualWall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PVirtualWall& a, PVirtualWall& b) {
    a.Swap(&b);
  }
  inline void Swap(PVirtualWall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PVirtualWall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PVirtualWall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PVirtualWall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PVirtualWall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PVirtualWall& from) {
    PVirtualWall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PVirtualWall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.NavData.PVirtualWall";
  }
  protected:
  explicit PVirtualWall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 5,
    kMapValueFieldNumber = 4,
    kValidFieldNumber = 1,
    kEnableFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // repeated .ZimaProto.Map.PMapPoint points = 5;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::ZimaProto::Map::PMapPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >*
      mutable_points();
  private:
  const ::ZimaProto::Map::PMapPoint& _internal_points(int index) const;
  ::ZimaProto::Map::PMapPoint* _internal_add_points();
  public:
  const ::ZimaProto::Map::PMapPoint& points(int index) const;
  ::ZimaProto::Map::PMapPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >&
      points() const;

  // string map_value = 4;
  void clear_map_value();
  const std::string& map_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_value();
  PROTOBUF_NODISCARD std::string* release_map_value();
  void set_allocated_map_value(std::string* map_value);
  private:
  const std::string& _internal_map_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_value(const std::string& value);
  std::string* _internal_mutable_map_value();
  public:

  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // bool enable = 2;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // .ZimaProto.NavData.PUserBlockType type = 3;
  void clear_type();
  ::ZimaProto::NavData::PUserBlockType type() const;
  void set_type(::ZimaProto::NavData::PUserBlockType value);
  private:
  ::ZimaProto::NavData::PUserBlockType _internal_type() const;
  void _internal_set_type(::ZimaProto::NavData::PUserBlockType value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.NavData.PVirtualWall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_value_;
    bool valid_;
    bool enable_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PBlockArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.NavData.PBlockArea) */ {
 public:
  inline PBlockArea() : PBlockArea(nullptr) {}
  ~PBlockArea() override;
  explicit PROTOBUF_CONSTEXPR PBlockArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBlockArea(const PBlockArea& from);
  PBlockArea(PBlockArea&& from) noexcept
    : PBlockArea() {
    *this = ::std::move(from);
  }

  inline PBlockArea& operator=(const PBlockArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBlockArea& operator=(PBlockArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBlockArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBlockArea* internal_default_instance() {
    return reinterpret_cast<const PBlockArea*>(
               &_PBlockArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PBlockArea& a, PBlockArea& b) {
    a.Swap(&b);
  }
  inline void Swap(PBlockArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBlockArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBlockArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBlockArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBlockArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PBlockArea& from) {
    PBlockArea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBlockArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.NavData.PBlockArea";
  }
  protected:
  explicit PBlockArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 5,
    kMapValueFieldNumber = 4,
    kValidFieldNumber = 1,
    kEnableFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // repeated .ZimaProto.Map.PMapPoint points = 5;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::ZimaProto::Map::PMapPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >*
      mutable_points();
  private:
  const ::ZimaProto::Map::PMapPoint& _internal_points(int index) const;
  ::ZimaProto::Map::PMapPoint* _internal_add_points();
  public:
  const ::ZimaProto::Map::PMapPoint& points(int index) const;
  ::ZimaProto::Map::PMapPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >&
      points() const;

  // string map_value = 4;
  void clear_map_value();
  const std::string& map_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_value();
  PROTOBUF_NODISCARD std::string* release_map_value();
  void set_allocated_map_value(std::string* map_value);
  private:
  const std::string& _internal_map_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_value(const std::string& value);
  std::string* _internal_mutable_map_value();
  public:

  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // bool enable = 2;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // .ZimaProto.NavData.PUserBlockType type = 3;
  void clear_type();
  ::ZimaProto::NavData::PUserBlockType type() const;
  void set_type(::ZimaProto::NavData::PUserBlockType value);
  private:
  ::ZimaProto::NavData::PUserBlockType _internal_type() const;
  void _internal_set_type(::ZimaProto::NavData::PUserBlockType value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.NavData.PBlockArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_value_;
    bool valid_;
    bool enable_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PNavData_RoomsInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_RoomsInfoEntry_DoNotUse, 
    std::string, ::ZimaProto::NavData::PRoomInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_RoomsInfoEntry_DoNotUse, 
    std::string, ::ZimaProto::NavData::PRoomInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PNavData_RoomsInfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PNavData_RoomsInfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PNavData_RoomsInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PNavData_RoomsInfoEntry_DoNotUse& other);
  static const PNavData_RoomsInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PNavData_RoomsInfoEntry_DoNotUse*>(&_PNavData_RoomsInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ZimaProto.NavData.PNavData.RoomsInfoEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};

// -------------------------------------------------------------------

class PNavData_VirtualWallsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_VirtualWallsEntry_DoNotUse, 
    uint32_t, ::ZimaProto::NavData::PVirtualWall,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_VirtualWallsEntry_DoNotUse, 
    uint32_t, ::ZimaProto::NavData::PVirtualWall,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PNavData_VirtualWallsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PNavData_VirtualWallsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PNavData_VirtualWallsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PNavData_VirtualWallsEntry_DoNotUse& other);
  static const PNavData_VirtualWallsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PNavData_VirtualWallsEntry_DoNotUse*>(&_PNavData_VirtualWallsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};

// -------------------------------------------------------------------

class PNavData_BlockAreasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_BlockAreasEntry_DoNotUse, 
    uint32_t, ::ZimaProto::NavData::PBlockArea,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PNavData_BlockAreasEntry_DoNotUse, 
    uint32_t, ::ZimaProto::NavData::PBlockArea,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PNavData_BlockAreasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PNavData_BlockAreasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PNavData_BlockAreasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PNavData_BlockAreasEntry_DoNotUse& other);
  static const PNavData_BlockAreasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PNavData_BlockAreasEntry_DoNotUse*>(&_PNavData_BlockAreasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};

// -------------------------------------------------------------------

class PNavData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZimaProto.NavData.PNavData) */ {
 public:
  inline PNavData() : PNavData(nullptr) {}
  ~PNavData() override;
  explicit PROTOBUF_CONSTEXPR PNavData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PNavData(const PNavData& from);
  PNavData(PNavData&& from) noexcept
    : PNavData() {
    *this = ::std::move(from);
  }

  inline PNavData& operator=(const PNavData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNavData& operator=(PNavData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PNavData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PNavData* internal_default_instance() {
    return reinterpret_cast<const PNavData*>(
               &_PNavData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PNavData& a, PNavData& b) {
    a.Swap(&b);
  }
  inline void Swap(PNavData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PNavData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PNavData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PNavData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PNavData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PNavData& from) {
    PNavData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNavData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZimaProto.NavData.PNavData";
  }
  protected:
  explicit PNavData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRoomsInfoFieldNumber = 6,
    kVirtualWallsFieldNumber = 7,
    kBlockAreasFieldNumber = 8,
    kSlamMapFilenameFieldNumber = 5,
    kNavMapFieldNumber = 2,
    kSlamMapFieldNumber = 3,
    kProbabilityMapFieldNumber = 4,
    kIndexFieldNumber = 1,
  };
  // map<string, .ZimaProto.NavData.PRoomInfo> rooms_info = 6;
  int rooms_info_size() const;
  private:
  int _internal_rooms_info_size() const;
  public:
  void clear_rooms_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >&
      _internal_rooms_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >*
      _internal_mutable_rooms_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >&
      rooms_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >*
      mutable_rooms_info();

  // map<uint32, .ZimaProto.NavData.PVirtualWall> virtual_walls = 7;
  int virtual_walls_size() const;
  private:
  int _internal_virtual_walls_size() const;
  public:
  void clear_virtual_walls();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >&
      _internal_virtual_walls() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >*
      _internal_mutable_virtual_walls();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >&
      virtual_walls() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >*
      mutable_virtual_walls();

  // map<uint32, .ZimaProto.NavData.PBlockArea> block_areas = 8;
  int block_areas_size() const;
  private:
  int _internal_block_areas_size() const;
  public:
  void clear_block_areas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >&
      _internal_block_areas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >*
      _internal_mutable_block_areas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >&
      block_areas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >*
      mutable_block_areas();

  // string slam_map_filename = 5;
  void clear_slam_map_filename();
  const std::string& slam_map_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slam_map_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slam_map_filename();
  PROTOBUF_NODISCARD std::string* release_slam_map_filename();
  void set_allocated_slam_map_filename(std::string* slam_map_filename);
  private:
  const std::string& _internal_slam_map_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slam_map_filename(const std::string& value);
  std::string* _internal_mutable_slam_map_filename();
  public:

  // .ZimaProto.Map.PMultiLayerCharGridMap2D nav_map = 2;
  bool has_nav_map() const;
  private:
  bool _internal_has_nav_map() const;
  public:
  void clear_nav_map();
  const ::ZimaProto::Map::PMultiLayerCharGridMap2D& nav_map() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PMultiLayerCharGridMap2D* release_nav_map();
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* mutable_nav_map();
  void set_allocated_nav_map(::ZimaProto::Map::PMultiLayerCharGridMap2D* nav_map);
  private:
  const ::ZimaProto::Map::PMultiLayerCharGridMap2D& _internal_nav_map() const;
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* _internal_mutable_nav_map();
  public:
  void unsafe_arena_set_allocated_nav_map(
      ::ZimaProto::Map::PMultiLayerCharGridMap2D* nav_map);
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* unsafe_arena_release_nav_map();

  // .ZimaProto.Map.PSlamValueGridMap2D slam_map = 3;
  bool has_slam_map() const;
  private:
  bool _internal_has_slam_map() const;
  public:
  void clear_slam_map();
  const ::ZimaProto::Map::PSlamValueGridMap2D& slam_map() const;
  PROTOBUF_NODISCARD ::ZimaProto::Map::PSlamValueGridMap2D* release_slam_map();
  ::ZimaProto::Map::PSlamValueGridMap2D* mutable_slam_map();
  void set_allocated_slam_map(::ZimaProto::Map::PSlamValueGridMap2D* slam_map);
  private:
  const ::ZimaProto::Map::PSlamValueGridMap2D& _internal_slam_map() const;
  ::ZimaProto::Map::PSlamValueGridMap2D* _internal_mutable_slam_map();
  public:
  void unsafe_arena_set_allocated_slam_map(
      ::ZimaProto::Map::PSlamValueGridMap2D* slam_map);
  ::ZimaProto::Map::PSlamValueGridMap2D* unsafe_arena_release_slam_map();

  // .ZimaProto.ProbabilityMap.PProbabilityIndexGridMap2D probability_map = 4;
  bool has_probability_map() const;
  private:
  bool _internal_has_probability_map() const;
  public:
  void clear_probability_map();
  const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D& probability_map() const;
  PROTOBUF_NODISCARD ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* release_probability_map();
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* mutable_probability_map();
  void set_allocated_probability_map(::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* probability_map);
  private:
  const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D& _internal_probability_map() const;
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* _internal_mutable_probability_map();
  public:
  void unsafe_arena_set_allocated_probability_map(
      ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* probability_map);
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* unsafe_arena_release_probability_map();

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ZimaProto.NavData.PNavData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PNavData_RoomsInfoEntry_DoNotUse,
        std::string, ::ZimaProto::NavData::PRoomInfo,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> rooms_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PNavData_VirtualWallsEntry_DoNotUse,
        uint32_t, ::ZimaProto::NavData::PVirtualWall,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> virtual_walls_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PNavData_BlockAreasEntry_DoNotUse,
        uint32_t, ::ZimaProto::NavData::PBlockArea,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> block_areas_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slam_map_filename_;
    ::ZimaProto::Map::PMultiLayerCharGridMap2D* nav_map_;
    ::ZimaProto::Map::PSlamValueGridMap2D* slam_map_;
    ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* probability_map_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zima_2fproto_2fnav_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PRoomInfo

// string room_index = 1;
inline void PRoomInfo::clear_room_index() {
  _impl_.room_index_.ClearToEmpty();
}
inline const std::string& PRoomInfo::room_index() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PRoomInfo.room_index)
  return _internal_room_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PRoomInfo::set_room_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PRoomInfo.room_index)
}
inline std::string* PRoomInfo::mutable_room_index() {
  std::string* _s = _internal_mutable_room_index();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PRoomInfo.room_index)
  return _s;
}
inline const std::string& PRoomInfo::_internal_room_index() const {
  return _impl_.room_index_.Get();
}
inline void PRoomInfo::_internal_set_room_index(const std::string& value) {
  
  _impl_.room_index_.Set(value, GetArenaForAllocation());
}
inline std::string* PRoomInfo::_internal_mutable_room_index() {
  
  return _impl_.room_index_.Mutable(GetArenaForAllocation());
}
inline std::string* PRoomInfo::release_room_index() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PRoomInfo.room_index)
  return _impl_.room_index_.Release();
}
inline void PRoomInfo::set_allocated_room_index(std::string* room_index) {
  if (room_index != nullptr) {
    
  } else {
    
  }
  _impl_.room_index_.SetAllocated(room_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_index_.IsDefault()) {
    _impl_.room_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PRoomInfo.room_index)
}

// .ZimaProto.Map.PMapCellBound room_bound = 2;
inline bool PRoomInfo::_internal_has_room_bound() const {
  return this != internal_default_instance() && _impl_.room_bound_ != nullptr;
}
inline bool PRoomInfo::has_room_bound() const {
  return _internal_has_room_bound();
}
inline const ::ZimaProto::Map::PMapCellBound& PRoomInfo::_internal_room_bound() const {
  const ::ZimaProto::Map::PMapCellBound* p = _impl_.room_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PMapCellBound&>(
      ::ZimaProto::Map::_PMapCellBound_default_instance_);
}
inline const ::ZimaProto::Map::PMapCellBound& PRoomInfo::room_bound() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PRoomInfo.room_bound)
  return _internal_room_bound();
}
inline void PRoomInfo::unsafe_arena_set_allocated_room_bound(
    ::ZimaProto::Map::PMapCellBound* room_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_bound_);
  }
  _impl_.room_bound_ = room_bound;
  if (room_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.NavData.PRoomInfo.room_bound)
}
inline ::ZimaProto::Map::PMapCellBound* PRoomInfo::release_room_bound() {
  
  ::ZimaProto::Map::PMapCellBound* temp = _impl_.room_bound_;
  _impl_.room_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PMapCellBound* PRoomInfo::unsafe_arena_release_room_bound() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PRoomInfo.room_bound)
  
  ::ZimaProto::Map::PMapCellBound* temp = _impl_.room_bound_;
  _impl_.room_bound_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PMapCellBound* PRoomInfo::_internal_mutable_room_bound() {
  
  if (_impl_.room_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PMapCellBound>(GetArenaForAllocation());
    _impl_.room_bound_ = p;
  }
  return _impl_.room_bound_;
}
inline ::ZimaProto::Map::PMapCellBound* PRoomInfo::mutable_room_bound() {
  ::ZimaProto::Map::PMapCellBound* _msg = _internal_mutable_room_bound();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PRoomInfo.room_bound)
  return _msg;
}
inline void PRoomInfo::set_allocated_room_bound(::ZimaProto::Map::PMapCellBound* room_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_bound_);
  }
  if (room_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room_bound));
    if (message_arena != submessage_arena) {
      room_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room_bound, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_bound_ = room_bound;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PRoomInfo.room_bound)
}

// .ZimaProto.Map.PMapCell section_base_cell = 3;
inline bool PRoomInfo::_internal_has_section_base_cell() const {
  return this != internal_default_instance() && _impl_.section_base_cell_ != nullptr;
}
inline bool PRoomInfo::has_section_base_cell() const {
  return _internal_has_section_base_cell();
}
inline const ::ZimaProto::Map::PMapCell& PRoomInfo::_internal_section_base_cell() const {
  const ::ZimaProto::Map::PMapCell* p = _impl_.section_base_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PMapCell&>(
      ::ZimaProto::Map::_PMapCell_default_instance_);
}
inline const ::ZimaProto::Map::PMapCell& PRoomInfo::section_base_cell() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PRoomInfo.section_base_cell)
  return _internal_section_base_cell();
}
inline void PRoomInfo::unsafe_arena_set_allocated_section_base_cell(
    ::ZimaProto::Map::PMapCell* section_base_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_base_cell_);
  }
  _impl_.section_base_cell_ = section_base_cell;
  if (section_base_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.NavData.PRoomInfo.section_base_cell)
}
inline ::ZimaProto::Map::PMapCell* PRoomInfo::release_section_base_cell() {
  
  ::ZimaProto::Map::PMapCell* temp = _impl_.section_base_cell_;
  _impl_.section_base_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PMapCell* PRoomInfo::unsafe_arena_release_section_base_cell() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PRoomInfo.section_base_cell)
  
  ::ZimaProto::Map::PMapCell* temp = _impl_.section_base_cell_;
  _impl_.section_base_cell_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PMapCell* PRoomInfo::_internal_mutable_section_base_cell() {
  
  if (_impl_.section_base_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PMapCell>(GetArenaForAllocation());
    _impl_.section_base_cell_ = p;
  }
  return _impl_.section_base_cell_;
}
inline ::ZimaProto::Map::PMapCell* PRoomInfo::mutable_section_base_cell() {
  ::ZimaProto::Map::PMapCell* _msg = _internal_mutable_section_base_cell();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PRoomInfo.section_base_cell)
  return _msg;
}
inline void PRoomInfo::set_allocated_section_base_cell(::ZimaProto::Map::PMapCell* section_base_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_base_cell_);
  }
  if (section_base_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(section_base_cell));
    if (message_arena != submessage_arena) {
      section_base_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, section_base_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.section_base_cell_ = section_base_cell;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PRoomInfo.section_base_cell)
}

// uint32 section_x_range = 4;
inline void PRoomInfo::clear_section_x_range() {
  _impl_.section_x_range_ = 0u;
}
inline uint32_t PRoomInfo::_internal_section_x_range() const {
  return _impl_.section_x_range_;
}
inline uint32_t PRoomInfo::section_x_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PRoomInfo.section_x_range)
  return _internal_section_x_range();
}
inline void PRoomInfo::_internal_set_section_x_range(uint32_t value) {
  
  _impl_.section_x_range_ = value;
}
inline void PRoomInfo::set_section_x_range(uint32_t value) {
  _internal_set_section_x_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PRoomInfo.section_x_range)
}

// uint32 section_y_range = 5;
inline void PRoomInfo::clear_section_y_range() {
  _impl_.section_y_range_ = 0u;
}
inline uint32_t PRoomInfo::_internal_section_y_range() const {
  return _impl_.section_y_range_;
}
inline uint32_t PRoomInfo::section_y_range() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PRoomInfo.section_y_range)
  return _internal_section_y_range();
}
inline void PRoomInfo::_internal_set_section_y_range(uint32_t value) {
  
  _impl_.section_y_range_ = value;
}
inline void PRoomInfo::set_section_y_range(uint32_t value) {
  _internal_set_section_y_range(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PRoomInfo.section_y_range)
}

// -------------------------------------------------------------------

// PVirtualWall

// bool valid = 1;
inline void PVirtualWall::clear_valid() {
  _impl_.valid_ = false;
}
inline bool PVirtualWall::_internal_valid() const {
  return _impl_.valid_;
}
inline bool PVirtualWall::valid() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PVirtualWall.valid)
  return _internal_valid();
}
inline void PVirtualWall::_internal_set_valid(bool value) {
  
  _impl_.valid_ = value;
}
inline void PVirtualWall::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PVirtualWall.valid)
}

// bool enable = 2;
inline void PVirtualWall::clear_enable() {
  _impl_.enable_ = false;
}
inline bool PVirtualWall::_internal_enable() const {
  return _impl_.enable_;
}
inline bool PVirtualWall::enable() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PVirtualWall.enable)
  return _internal_enable();
}
inline void PVirtualWall::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void PVirtualWall::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PVirtualWall.enable)
}

// .ZimaProto.NavData.PUserBlockType type = 3;
inline void PVirtualWall::clear_type() {
  _impl_.type_ = 0;
}
inline ::ZimaProto::NavData::PUserBlockType PVirtualWall::_internal_type() const {
  return static_cast< ::ZimaProto::NavData::PUserBlockType >(_impl_.type_);
}
inline ::ZimaProto::NavData::PUserBlockType PVirtualWall::type() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PVirtualWall.type)
  return _internal_type();
}
inline void PVirtualWall::_internal_set_type(::ZimaProto::NavData::PUserBlockType value) {
  
  _impl_.type_ = value;
}
inline void PVirtualWall::set_type(::ZimaProto::NavData::PUserBlockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PVirtualWall.type)
}

// string map_value = 4;
inline void PVirtualWall::clear_map_value() {
  _impl_.map_value_.ClearToEmpty();
}
inline const std::string& PVirtualWall::map_value() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PVirtualWall.map_value)
  return _internal_map_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PVirtualWall::set_map_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PVirtualWall.map_value)
}
inline std::string* PVirtualWall::mutable_map_value() {
  std::string* _s = _internal_mutable_map_value();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PVirtualWall.map_value)
  return _s;
}
inline const std::string& PVirtualWall::_internal_map_value() const {
  return _impl_.map_value_.Get();
}
inline void PVirtualWall::_internal_set_map_value(const std::string& value) {
  
  _impl_.map_value_.Set(value, GetArenaForAllocation());
}
inline std::string* PVirtualWall::_internal_mutable_map_value() {
  
  return _impl_.map_value_.Mutable(GetArenaForAllocation());
}
inline std::string* PVirtualWall::release_map_value() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PVirtualWall.map_value)
  return _impl_.map_value_.Release();
}
inline void PVirtualWall::set_allocated_map_value(std::string* map_value) {
  if (map_value != nullptr) {
    
  } else {
    
  }
  _impl_.map_value_.SetAllocated(map_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_value_.IsDefault()) {
    _impl_.map_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PVirtualWall.map_value)
}

// repeated .ZimaProto.Map.PMapPoint points = 5;
inline int PVirtualWall::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int PVirtualWall::points_size() const {
  return _internal_points_size();
}
inline ::ZimaProto::Map::PMapPoint* PVirtualWall::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PVirtualWall.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >*
PVirtualWall::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ZimaProto.NavData.PVirtualWall.points)
  return &_impl_.points_;
}
inline const ::ZimaProto::Map::PMapPoint& PVirtualWall::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::ZimaProto::Map::PMapPoint& PVirtualWall::points(int index) const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PVirtualWall.points)
  return _internal_points(index);
}
inline ::ZimaProto::Map::PMapPoint* PVirtualWall::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::ZimaProto::Map::PMapPoint* PVirtualWall::add_points() {
  ::ZimaProto::Map::PMapPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:ZimaProto.NavData.PVirtualWall.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >&
PVirtualWall::points() const {
  // @@protoc_insertion_point(field_list:ZimaProto.NavData.PVirtualWall.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// PBlockArea

// bool valid = 1;
inline void PBlockArea::clear_valid() {
  _impl_.valid_ = false;
}
inline bool PBlockArea::_internal_valid() const {
  return _impl_.valid_;
}
inline bool PBlockArea::valid() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PBlockArea.valid)
  return _internal_valid();
}
inline void PBlockArea::_internal_set_valid(bool value) {
  
  _impl_.valid_ = value;
}
inline void PBlockArea::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PBlockArea.valid)
}

// bool enable = 2;
inline void PBlockArea::clear_enable() {
  _impl_.enable_ = false;
}
inline bool PBlockArea::_internal_enable() const {
  return _impl_.enable_;
}
inline bool PBlockArea::enable() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PBlockArea.enable)
  return _internal_enable();
}
inline void PBlockArea::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void PBlockArea::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PBlockArea.enable)
}

// .ZimaProto.NavData.PUserBlockType type = 3;
inline void PBlockArea::clear_type() {
  _impl_.type_ = 0;
}
inline ::ZimaProto::NavData::PUserBlockType PBlockArea::_internal_type() const {
  return static_cast< ::ZimaProto::NavData::PUserBlockType >(_impl_.type_);
}
inline ::ZimaProto::NavData::PUserBlockType PBlockArea::type() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PBlockArea.type)
  return _internal_type();
}
inline void PBlockArea::_internal_set_type(::ZimaProto::NavData::PUserBlockType value) {
  
  _impl_.type_ = value;
}
inline void PBlockArea::set_type(::ZimaProto::NavData::PUserBlockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PBlockArea.type)
}

// string map_value = 4;
inline void PBlockArea::clear_map_value() {
  _impl_.map_value_.ClearToEmpty();
}
inline const std::string& PBlockArea::map_value() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PBlockArea.map_value)
  return _internal_map_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBlockArea::set_map_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PBlockArea.map_value)
}
inline std::string* PBlockArea::mutable_map_value() {
  std::string* _s = _internal_mutable_map_value();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PBlockArea.map_value)
  return _s;
}
inline const std::string& PBlockArea::_internal_map_value() const {
  return _impl_.map_value_.Get();
}
inline void PBlockArea::_internal_set_map_value(const std::string& value) {
  
  _impl_.map_value_.Set(value, GetArenaForAllocation());
}
inline std::string* PBlockArea::_internal_mutable_map_value() {
  
  return _impl_.map_value_.Mutable(GetArenaForAllocation());
}
inline std::string* PBlockArea::release_map_value() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PBlockArea.map_value)
  return _impl_.map_value_.Release();
}
inline void PBlockArea::set_allocated_map_value(std::string* map_value) {
  if (map_value != nullptr) {
    
  } else {
    
  }
  _impl_.map_value_.SetAllocated(map_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_value_.IsDefault()) {
    _impl_.map_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PBlockArea.map_value)
}

// repeated .ZimaProto.Map.PMapPoint points = 5;
inline int PBlockArea::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int PBlockArea::points_size() const {
  return _internal_points_size();
}
inline ::ZimaProto::Map::PMapPoint* PBlockArea::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PBlockArea.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >*
PBlockArea::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ZimaProto.NavData.PBlockArea.points)
  return &_impl_.points_;
}
inline const ::ZimaProto::Map::PMapPoint& PBlockArea::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::ZimaProto::Map::PMapPoint& PBlockArea::points(int index) const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PBlockArea.points)
  return _internal_points(index);
}
inline ::ZimaProto::Map::PMapPoint* PBlockArea::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::ZimaProto::Map::PMapPoint* PBlockArea::add_points() {
  ::ZimaProto::Map::PMapPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:ZimaProto.NavData.PBlockArea.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZimaProto::Map::PMapPoint >&
PBlockArea::points() const {
  // @@protoc_insertion_point(field_list:ZimaProto.NavData.PBlockArea.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PNavData

// uint32 index = 1;
inline void PNavData::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t PNavData::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t PNavData::index() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PNavData.index)
  return _internal_index();
}
inline void PNavData::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void PNavData::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PNavData.index)
}

// .ZimaProto.Map.PMultiLayerCharGridMap2D nav_map = 2;
inline bool PNavData::_internal_has_nav_map() const {
  return this != internal_default_instance() && _impl_.nav_map_ != nullptr;
}
inline bool PNavData::has_nav_map() const {
  return _internal_has_nav_map();
}
inline const ::ZimaProto::Map::PMultiLayerCharGridMap2D& PNavData::_internal_nav_map() const {
  const ::ZimaProto::Map::PMultiLayerCharGridMap2D* p = _impl_.nav_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PMultiLayerCharGridMap2D&>(
      ::ZimaProto::Map::_PMultiLayerCharGridMap2D_default_instance_);
}
inline const ::ZimaProto::Map::PMultiLayerCharGridMap2D& PNavData::nav_map() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PNavData.nav_map)
  return _internal_nav_map();
}
inline void PNavData::unsafe_arena_set_allocated_nav_map(
    ::ZimaProto::Map::PMultiLayerCharGridMap2D* nav_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nav_map_);
  }
  _impl_.nav_map_ = nav_map;
  if (nav_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.NavData.PNavData.nav_map)
}
inline ::ZimaProto::Map::PMultiLayerCharGridMap2D* PNavData::release_nav_map() {
  
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* temp = _impl_.nav_map_;
  _impl_.nav_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PMultiLayerCharGridMap2D* PNavData::unsafe_arena_release_nav_map() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PNavData.nav_map)
  
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* temp = _impl_.nav_map_;
  _impl_.nav_map_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PMultiLayerCharGridMap2D* PNavData::_internal_mutable_nav_map() {
  
  if (_impl_.nav_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PMultiLayerCharGridMap2D>(GetArenaForAllocation());
    _impl_.nav_map_ = p;
  }
  return _impl_.nav_map_;
}
inline ::ZimaProto::Map::PMultiLayerCharGridMap2D* PNavData::mutable_nav_map() {
  ::ZimaProto::Map::PMultiLayerCharGridMap2D* _msg = _internal_mutable_nav_map();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PNavData.nav_map)
  return _msg;
}
inline void PNavData::set_allocated_nav_map(::ZimaProto::Map::PMultiLayerCharGridMap2D* nav_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nav_map_);
  }
  if (nav_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nav_map));
    if (message_arena != submessage_arena) {
      nav_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nav_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nav_map_ = nav_map;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PNavData.nav_map)
}

// .ZimaProto.Map.PSlamValueGridMap2D slam_map = 3;
inline bool PNavData::_internal_has_slam_map() const {
  return this != internal_default_instance() && _impl_.slam_map_ != nullptr;
}
inline bool PNavData::has_slam_map() const {
  return _internal_has_slam_map();
}
inline const ::ZimaProto::Map::PSlamValueGridMap2D& PNavData::_internal_slam_map() const {
  const ::ZimaProto::Map::PSlamValueGridMap2D* p = _impl_.slam_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::Map::PSlamValueGridMap2D&>(
      ::ZimaProto::Map::_PSlamValueGridMap2D_default_instance_);
}
inline const ::ZimaProto::Map::PSlamValueGridMap2D& PNavData::slam_map() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PNavData.slam_map)
  return _internal_slam_map();
}
inline void PNavData::unsafe_arena_set_allocated_slam_map(
    ::ZimaProto::Map::PSlamValueGridMap2D* slam_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slam_map_);
  }
  _impl_.slam_map_ = slam_map;
  if (slam_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.NavData.PNavData.slam_map)
}
inline ::ZimaProto::Map::PSlamValueGridMap2D* PNavData::release_slam_map() {
  
  ::ZimaProto::Map::PSlamValueGridMap2D* temp = _impl_.slam_map_;
  _impl_.slam_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::Map::PSlamValueGridMap2D* PNavData::unsafe_arena_release_slam_map() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PNavData.slam_map)
  
  ::ZimaProto::Map::PSlamValueGridMap2D* temp = _impl_.slam_map_;
  _impl_.slam_map_ = nullptr;
  return temp;
}
inline ::ZimaProto::Map::PSlamValueGridMap2D* PNavData::_internal_mutable_slam_map() {
  
  if (_impl_.slam_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::Map::PSlamValueGridMap2D>(GetArenaForAllocation());
    _impl_.slam_map_ = p;
  }
  return _impl_.slam_map_;
}
inline ::ZimaProto::Map::PSlamValueGridMap2D* PNavData::mutable_slam_map() {
  ::ZimaProto::Map::PSlamValueGridMap2D* _msg = _internal_mutable_slam_map();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PNavData.slam_map)
  return _msg;
}
inline void PNavData::set_allocated_slam_map(::ZimaProto::Map::PSlamValueGridMap2D* slam_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slam_map_);
  }
  if (slam_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slam_map));
    if (message_arena != submessage_arena) {
      slam_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slam_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.slam_map_ = slam_map;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PNavData.slam_map)
}

// .ZimaProto.ProbabilityMap.PProbabilityIndexGridMap2D probability_map = 4;
inline bool PNavData::_internal_has_probability_map() const {
  return this != internal_default_instance() && _impl_.probability_map_ != nullptr;
}
inline bool PNavData::has_probability_map() const {
  return _internal_has_probability_map();
}
inline const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D& PNavData::_internal_probability_map() const {
  const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* p = _impl_.probability_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D&>(
      ::ZimaProto::ProbabilityMap::_PProbabilityIndexGridMap2D_default_instance_);
}
inline const ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D& PNavData::probability_map() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PNavData.probability_map)
  return _internal_probability_map();
}
inline void PNavData::unsafe_arena_set_allocated_probability_map(
    ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* probability_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.probability_map_);
  }
  _impl_.probability_map_ = probability_map;
  if (probability_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZimaProto.NavData.PNavData.probability_map)
}
inline ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* PNavData::release_probability_map() {
  
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* temp = _impl_.probability_map_;
  _impl_.probability_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* PNavData::unsafe_arena_release_probability_map() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PNavData.probability_map)
  
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* temp = _impl_.probability_map_;
  _impl_.probability_map_ = nullptr;
  return temp;
}
inline ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* PNavData::_internal_mutable_probability_map() {
  
  if (_impl_.probability_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D>(GetArenaForAllocation());
    _impl_.probability_map_ = p;
  }
  return _impl_.probability_map_;
}
inline ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* PNavData::mutable_probability_map() {
  ::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* _msg = _internal_mutable_probability_map();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PNavData.probability_map)
  return _msg;
}
inline void PNavData::set_allocated_probability_map(::ZimaProto::ProbabilityMap::PProbabilityIndexGridMap2D* probability_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.probability_map_);
  }
  if (probability_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(probability_map));
    if (message_arena != submessage_arena) {
      probability_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, probability_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.probability_map_ = probability_map;
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PNavData.probability_map)
}

// string slam_map_filename = 5;
inline void PNavData::clear_slam_map_filename() {
  _impl_.slam_map_filename_.ClearToEmpty();
}
inline const std::string& PNavData::slam_map_filename() const {
  // @@protoc_insertion_point(field_get:ZimaProto.NavData.PNavData.slam_map_filename)
  return _internal_slam_map_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PNavData::set_slam_map_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.slam_map_filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ZimaProto.NavData.PNavData.slam_map_filename)
}
inline std::string* PNavData::mutable_slam_map_filename() {
  std::string* _s = _internal_mutable_slam_map_filename();
  // @@protoc_insertion_point(field_mutable:ZimaProto.NavData.PNavData.slam_map_filename)
  return _s;
}
inline const std::string& PNavData::_internal_slam_map_filename() const {
  return _impl_.slam_map_filename_.Get();
}
inline void PNavData::_internal_set_slam_map_filename(const std::string& value) {
  
  _impl_.slam_map_filename_.Set(value, GetArenaForAllocation());
}
inline std::string* PNavData::_internal_mutable_slam_map_filename() {
  
  return _impl_.slam_map_filename_.Mutable(GetArenaForAllocation());
}
inline std::string* PNavData::release_slam_map_filename() {
  // @@protoc_insertion_point(field_release:ZimaProto.NavData.PNavData.slam_map_filename)
  return _impl_.slam_map_filename_.Release();
}
inline void PNavData::set_allocated_slam_map_filename(std::string* slam_map_filename) {
  if (slam_map_filename != nullptr) {
    
  } else {
    
  }
  _impl_.slam_map_filename_.SetAllocated(slam_map_filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slam_map_filename_.IsDefault()) {
    _impl_.slam_map_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ZimaProto.NavData.PNavData.slam_map_filename)
}

// map<string, .ZimaProto.NavData.PRoomInfo> rooms_info = 6;
inline int PNavData::_internal_rooms_info_size() const {
  return _impl_.rooms_info_.size();
}
inline int PNavData::rooms_info_size() const {
  return _internal_rooms_info_size();
}
inline void PNavData::clear_rooms_info() {
  _impl_.rooms_info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >&
PNavData::_internal_rooms_info() const {
  return _impl_.rooms_info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >&
PNavData::rooms_info() const {
  // @@protoc_insertion_point(field_map:ZimaProto.NavData.PNavData.rooms_info)
  return _internal_rooms_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >*
PNavData::_internal_mutable_rooms_info() {
  return _impl_.rooms_info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ZimaProto::NavData::PRoomInfo >*
PNavData::mutable_rooms_info() {
  // @@protoc_insertion_point(field_mutable_map:ZimaProto.NavData.PNavData.rooms_info)
  return _internal_mutable_rooms_info();
}

// map<uint32, .ZimaProto.NavData.PVirtualWall> virtual_walls = 7;
inline int PNavData::_internal_virtual_walls_size() const {
  return _impl_.virtual_walls_.size();
}
inline int PNavData::virtual_walls_size() const {
  return _internal_virtual_walls_size();
}
inline void PNavData::clear_virtual_walls() {
  _impl_.virtual_walls_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >&
PNavData::_internal_virtual_walls() const {
  return _impl_.virtual_walls_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >&
PNavData::virtual_walls() const {
  // @@protoc_insertion_point(field_map:ZimaProto.NavData.PNavData.virtual_walls)
  return _internal_virtual_walls();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >*
PNavData::_internal_mutable_virtual_walls() {
  return _impl_.virtual_walls_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PVirtualWall >*
PNavData::mutable_virtual_walls() {
  // @@protoc_insertion_point(field_mutable_map:ZimaProto.NavData.PNavData.virtual_walls)
  return _internal_mutable_virtual_walls();
}

// map<uint32, .ZimaProto.NavData.PBlockArea> block_areas = 8;
inline int PNavData::_internal_block_areas_size() const {
  return _impl_.block_areas_.size();
}
inline int PNavData::block_areas_size() const {
  return _internal_block_areas_size();
}
inline void PNavData::clear_block_areas() {
  _impl_.block_areas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >&
PNavData::_internal_block_areas() const {
  return _impl_.block_areas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >&
PNavData::block_areas() const {
  // @@protoc_insertion_point(field_map:ZimaProto.NavData.PNavData.block_areas)
  return _internal_block_areas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >*
PNavData::_internal_mutable_block_areas() {
  return _impl_.block_areas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::ZimaProto::NavData::PBlockArea >*
PNavData::mutable_block_areas() {
  // @@protoc_insertion_point(field_mutable_map:ZimaProto.NavData.PNavData.block_areas)
  return _internal_mutable_block_areas();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NavData
}  // namespace ZimaProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ZimaProto::NavData::PUserBlockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZimaProto::NavData::PUserBlockType>() {
  return ::ZimaProto::NavData::PUserBlockType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zima_2fproto_2fnav_5fdata_2eproto
